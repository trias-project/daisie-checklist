---
title: "Darwin Core mapping"
subtitle: "For: Inventory of alien species in Europe (DAISIE)"
author:
- Lien Reyserhove
- David Roy
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    number_sections: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
#  pdf_document:
#    df_print: kable
#    number_sections: yes
#    toc: yes
#    toc_depth: 3
---

# Setup 

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

Load libraries:

```{r}
library(tidyverse)      # To do data science
library(magrittr)       # To use %<>% pipes
library(here)           # To find files
library(janitor)        # To clean input data
library(readxl)         # To read Excel files
library(digest)         # To generate hashes
library(rgbif)          # To use GBIF services
library(lubridate)
```

# Read source data

```{r}
taxon <- read.csv("../data/raw/input_taxon.csv") 
vernacular_names <- read.csv("../data/raw/input_vernacular_names.csv")
distribution <- read.csv("../data/raw/input_distribution.csv", na.strings = "")
literature_references <- read.csv("../data/raw/input_literature_references.csv", na.strings = "")

# For the description extension:
pathways <- read.csv("../data/raw/input_pathways.csv")
vectors  <- read.csv("../data/raw/input_vectors.csv")
habitat <- read.csv("../data/raw/input_habitat.csv")
native_range <- read.csv("../data/raw/input_native_range.csv")
donor_area <- read.csv("../data/raw/input_donor_area.csv")
impact <- read.csv("../data/raw/input_impact.csv")
```

# Pre-processing

Each of the Darwin Core extension file contains a field `source`. In the taxon core, sources are integrated in the field `taxonRemarks`. The basic information for these fields is integrated in `literature_references`. 

Three fields contain information for `source`:
- shortref
- longref
- url

The information in `source` will be a combination between the information in `shortref` and `longref`

```{r}
arrange(
  bind_cols(
        data.frame(matrix(c("","","","","", "x","", "x","","", "x", "x", "x","","", "x","", "x", "x", "x","", "x", "x", "x"),
                       nrow = 8, byrow = TRUE, dimnames = list(c(1:8), c("longref", "shortref", "url")))),
        data.frame(bind_rows(summarize(filter(literature_references, is.na(longref) & is.na(shortref) & is.na(url)), records = n()),
                         summarize(filter(literature_references, is.na(longref) & is.na(shortref) & !is.na(url)), records = n()),
                         summarize(filter(literature_references, is.na(longref) & !is.na(shortref) & is.na(url)), records = n()),
                         summarize(filter(literature_references, is.na(longref) & !is.na(shortref) & !is.na(url)), records = n()),
                         summarize(filter(literature_references, !is.na(longref) & is.na(shortref) & is.na(url)), records = n()),
                         summarize(filter(literature_references, !is.na(longref) & is.na(shortref) & !is.na(url)), records = n()),
                         summarize(filter(literature_references, !is.na(longref) & !is.na(shortref) & is.na(url)), records = n()),
                         summarize(filter(literature_references, !is.na(longref) & !is.na(shortref) & !is.na(url)), records =n())))
        ),
  desc(records))
```

Conclusion:
 - In most cases, a longre and/or shortref is provided, without url
 - In only 165 cases, a url is provided.
 
 The information in `url` is, in most cases, wrong: it contains scientific names rather than a real url:

```{r}
literature_references %>%
  filter(!is.na(url)) %>%
  group_by(url) %>% 
  summarize(records = n()) 
```

In some cases howevever, `url` refers to a real url

```{r}
literature_references %>%
  filter(str_detect(url, "http")) %>% 
  group_by(shortref, longref) %>% 
  summarize(records = n())
```

We decided to integrate `url` only when no shortref or longref is provided.

```{r}
literature_references %<>% mutate(complete_ref = case_when(
  is.na(shortref) & is.na(longref) ~ paste(url),
  !is.na(shortref) & is.na(longref) ~ paste(shortref),
  !is.na(longref) ~ paste(longref)))
```

Extract references for later mapping of distribution information:

```{r}
distribution_references <- literature_references %>% filter(!is.na(id_sp_region))
```

Keep unique sources only:

```{r}
literature_references %<>% distinct(sourceid, .keep_all = TRUE)
```

# Taxon core

Preview data:

```{r}
taxon %>% head(n = 5)
```

## Term mapping

Map the data to [Darwin Core Taxon](http://rs.gbif.org/core/dwc_taxon_2015-04-24.xml).

Start with record-level terms which contain metadata about the dataset (which is generally the same for all records).

### language

```{r}
taxon %<>% mutate(dwc_language = "en") 
```

### license

```{r}
taxon %<>% mutate(dwc_license = "http://creativecommons.org/licenses/by/4.0/legalcode") 
```

### rightsHolder

```{r}
taxon %<>% mutate(dwc_rightsHolder = "Centre for Ecology and Hydrology")
```

### datasetID

```{r}
taxon %<>% mutate(dwc_datasetID = "") 
```

### institutionCode

```{r}
taxon %<>% mutate(dwc_institutionCode = "CEH") 
```

### datasetName

```{r}
taxon %<>% mutate(dwc_datasetName = "Inventory of alien species in Europe (DAISIE)") 
```

The following terms contain information about the taxon:

### taxonID

```{r}
taxon %<>% mutate(dwc_taxonID = idspecies)
```

### scientificName

The information in `scientificName` is contained in several fields: `sp_genus`, `sp_species`, `sp_authority`, `sp_subtaxon` and `sp_subtaxon_authority`. We paste this information together to generate the field `dwc_scientificName`:

```{r}
taxon %<>% mutate(dwc_scientificName = paste(genus, species, authority, subtaxon, subtaxon_authority, sep = " "))
```

Use the [GBIF nameparser](https://www.gbif.org/tools/name-parser) to retrieve nomenclatural information for the scientific names in the checklist:

```{r}
parsed_names <- taxon %>%
  distinct(dwc_scientificName) %>%
  pull() %>% # Create vector from dataframe
  parsenames() # An rgbif function
```

Show scientific names with nomenclatural issues, i.e. not of `type = SCIENTIFIC` or that could not be fully parsed. Note: these are not necessarily incorrect.

```{r}
nomenclatural_issues <- parsed_names %>%
  select(scientificname, type, parsed, parsedpartially, rankmarker) %>%
  filter(!(type == "SCIENTIFIC" & parsed == "TRUE" & parsedpartially == "FALSE"))
```

Amount of scientific names with nomenclatural issues:

```{r}
nrow(nomenclatural_issues)
```

Inspect how many taxa are categorized under the different types:

```{r}
nomenclatural_issues %>% 
  group_by(type) %>% 
  summarize(records = n())
```

Some taxa need special inspection, especially the doubtful ones (probably due to UTF-8 issues)

### kingdom

### phylum

```{r}
taxon %<>% mutate(dwc_phylum = phylum)
```

### class

```{r}
taxon %<>% mutate(dwc_class = class) 
```

### order

```{r}
taxon %<>% mutate(dwc_order = ordo) 
```

### family

```{r}
taxon %<>% mutate(dwc_family = family) 
```

### genus

```{r}
taxon %<>% mutate(dwc_genus = genus) 
```

### specificEpithet

```{r}
taxon %<>% mutate(dwc_specificEpithet = species) 
```

### infraspecificEpithet

```{r}
taxon %<>% mutate(dwc_infraspecificEpithet = subtaxon) 
```

### taxonRank

Information for `taxonRank` is provided in the field `subtaxon_rank`. However, this is only for the subtaxon level. The information is also provided by the GBIF nameparser function. We extract this information from the `parsed_names` and add it to `taxon`:

```{r}
taxon %<>% left_join(
  select(parsed_names, scientificname, rankmarker),
  by = c("dwc_scientificName" = "scientificname"))
```

Inspect `rankmarker` values and compare with `subtaxon_rank` information:

```{r}
taxon %>% 
  group_by(rankmarker, subtaxon_rank) %>% 
  summarize(records = n()) %>% 
  arrange(desc(records)) 
```

We decided to use the information contained in `rankmarker` because GBIF rankmarker will provide cleaner information than `subtaxon_rank`, even if there might be some loss of information.

Show unique values for `rankmarker`:

```{r}
taxon %>% distinct(rankmarker)
```


```{r}
taxon %<>% mutate(dwc_taxonRank = recode(rankmarker,
   "sp." = "species",
   "infrasp." = "infraspecificname",
   "cv." = "cultivar",
    "<NA>" = "",
   "infrasubsp." = "infrasubspecificname",
   "var." = "variety",
   "morph" = "morphovar",
   "subvar." = "subvariety",
   "subf." = "subform",
   "subsp." = "subspecies",
   "f." = "form",
   "pv." = "pathovar"
   ))
```

summarize mapping:

```{r}
taxon %>% 
  group_by(rankmarker, dwc_taxonRank) %>% 
  summarize(records = n()) %>% 
  arrange(desc(records)) 
```

### scientificNameAuthorship

The `taxon` file now contains two fields refering to an authorship: `authority` and `subtaxon_authority`. When values for `subtaxon_authority` are provided, we use these values as `scientificNameAuthorship`. If only a value for `authority` is provided, we use this value.

```{r}
taxon %<>% mutate(dwc_scientificNameAuthorship = case_when(
  authority == "" & subtaxon_authority == "" ~ authority,
  authority == "" & subtaxon_authority != "" ~ subtaxon_authority,
  authority != "" & subtaxon_authority == "" ~ authority,
  authority != "" & subtaxon_authority != "" ~ subtaxon_authority))
```

### taxonRemarks

`taxon` contains a reference to sources (`sourceid`) which can not be classified a bibliographic citations. For this reason, we map these sources here.

```{r}
taxon %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid")
```

Rename `complete_ref`:

```{r}
taxon %<>% rename("dwc_taxonRemarks" = "complete_ref") 
```

## Post-processing

Save information on ecofunctional groups (`ecofunct_group`):

```{r}
ecofunctional_group <- taxon %>% 
  select(idspecies, ecofunct_group, sourceid) %>% 
  distinct(idspecies, ecofunct_group, .keep_all = TRUE)
```

Save information about taxon group (`taxon_group`):

```{r}
taxon_group <- taxon %>% select(idspecies, taxon_group, sourceid) %>% 
  distinct(idspecies, taxon_group, .keep_all = TRUE)
```

Only keep the Darwin Core columns:

```{r}
taxon %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(taxon) <- str_replace(colnames(taxon), "dwc_", "")
```

Preview data:

```{r}
taxon %>% head()
```

Save to CSV:

```{r}
write_csv(taxon, "../data/processed/taxon.csv", na = "")
```

# Vernacular names extension

```{r}
vernacular_names %>% head(n = 5)
```

## Term mapping

### taxonID

```{r}
vernacular_names %<>% mutate(dwc_taxonID = idspecies) 
```

### vernacularName

```{r}
vernacular_names %<>% mutate(dwc_vernacularName = name) 
```

### source

Join `vernacular_names` with `complete_ref` information in `literature_references`:

```{r}
vernacular_names %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid"
) 
```

Rename `complete_ref`:

```{r}
vernacular_names %<>% rename("dwc_source" = "complete_ref") 
```


### language

Display all unique language information:

```{r}
vernacular_names %>% 
  group_by(language) %>% 
  summarize(records = n())
```

Map language information to [ISO 639-1 Language Codes](https://tools.gbif.org/dwca-validator/vocabulary.do?id=http://iso.org/639-1)

```{r}
vernacular_names %<>% mutate(dwc_language = recode(language,
  "Belorussian" = "be",
  "Czech" = "cs",
  "Danish" = "da",
  "Dutch" = "nl",
  "English" = "en",
  "Estonian" = "et",
  "Faeroese" = "fo",
  "Finnish" = "fi",
  "French" = "fr",
  "German" = "de",
  "Greek" = "el",
  "Hebrew (western characters)" = "he",
  "Hebrew (Hebrew characters)" = "he",
  "Hungarian" = "hu",
  "Icelandic" = "is",
  "Italian" = "it",
  "Latvian" = "lv",
  "Lithuanian" = "lt",
  "Maltese" = "mt",
  "Norwegian" = "no",
  "Polish" = "pl",
  "Portuguese" = "pt",
  "Romanian" = "ro",
  "Spanish" = "es",
  "Swedish" = "sv",
  "Turkish" = "tr"
))
```

Show mapping:

```{r}
vernacular_names %>% 
  group_by(language, dwc_language) %>% 
  summarize(records = n())
```

## Post-processing

Only keep the Darwin Core columns:

```{r}
vernacular_names %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(vernacular_names) <- str_replace(colnames(vernacular_names), "dwc_", "")
```

Preview data:

```{r}
vernacular_names %>% head()
```

Save to CSV:

```{r}
write_csv(vernacular_names, "../data/processed/vernacular_names.csv", na = "")
```

# Distribution extension

## taxonID

```{r}
distribution %<>% mutate(dwc_taxonID = idspecies) 
```

## locationID

In this field, we integrate information contained in `system_country`, `code_region`. When coastal information is provided, we combine this infomation with `system_coast` and `code_coast`.

```{r}
distribution %<>% mutate(dwc_locationID = case_when(
  is.na(region_coast) ~ paste(system_country, code_region, sep = ":"),
  TRUE ~ paste(
    paste(system_country, code_region, sep = ":"),
    paste(system_coast, code_coast, sep = ":"),
    sep = " - ")
))
```

## locality

In this field, we integrate all verbatim information contained in `region_country` and `region_coast` 
The format will be:

> country - coast

```{r}
distribution %<>% mutate(dwc_locality = case_when(
  is.na(region_coast) ~ paste(region_country),
  !is.na(region_coast) ~ paste(region_country, region_coast, sep = " - ")))
```

Save this information in a separate vector, as this is needed for the mapping of the description extension.

```{r}
species_localities <- distribution %>% 
  select(idspecies, id_sp_region, dwc_locationID) %>% 
  rename("locationID" = "dwc_locationID")
```

## countryCode

```{r}
distribution %<>% mutate(countryCode = recode(region_country, 
"Albania"	                = "AL",
"Algeria"	                = "DZ",
"Andorra"	                = "AD",
"Austria"	                = "AT",
"Azores"                  = "PT",
"Baleares"	              = "ES",
"Belarus"	                = "BY",
"Belgium"	                = "BE",
"Bosnia-Herzegovina"	    = "BA",
"Bulgaria"	              = "BG",
"Canary Is."	            = "ES",
"Channel Is."	            = "UK",
"Corse (Corsica)"	        = "FR",
"Croatia"	                = "HR",
"Cyprus"	                = "CY",
"Czech Republic"	        = "CZ",
"Denmark"	                = "DK",
"Egypt"                 	= "EG",
"England"	                = "UK",
"Estonia"                 = "ES",
"Europe"	                = "",
"European part of Russia"	= "RU",
"Faroyar (Faroes)"	      = "FO",
"Finland"	                = "FI",
"France"	                = "FRR",
"Germany"	                = "DE",
"Gilbraltar"	            = "GI",
"Great Britain"	          = "UK",
"Greece"	                = "GRC-OO",
"Greece (East Aegean)"	  = "GR",
"Greece (Ionian Islands)" = "GR",
"Greece (North Aegean)"   = "GR",
"Greece (South Aegean)"   = "GR",
"Greenland"	              = "GL",
"Hungary"	                = "HU",
"Iceland"	                = "IS",
"Ireland"	                = "IE",
"Israel"	                = "IL",
"Italy"	                  = "IT",
"Kriti (Crete)"	          = "GR",
"Latvia"	                = "LV",
"Lebanon"	                = "LB",
"Libya"	                  = "LY",
"Liechtenstein"	          = "LI",
"Lithuania"	              = "LT",
"Luxembourg"	            = "LU",
"Macedonia"	              = "MK",
"Madeira"	                = "PT",
"Malta"	                  = "MT",
"Moldova"	                = "MD",
"Monaco"	                = "MC",
"Montenegro"	            = "YU",
"Morocco"	                = "MA",
"Netherlands"	            = "NL",
"Northern Ireland"	      = "UK",
"Norway"	                = "NO",
"Poland"	                = "PL",
"Portugal"	              = "PT",
"Romania"	                = "RO",
"Russian Far East"	      = "31",
"San Marino"	            = "SM",
"Sardegna (Sardinia)"	    = "IT",
"Scotland"	              = "UK",
"Serbia"	                = "YU",
"Sicilia"	                = "IT",
"Sicilia (Sicily)"	      = "IT",
"Slovakia"	              = "SK",
"Slovenia"	              = "SI",
"Spain"	                  = "ES",
"Svalbard"	              = "SJ",
"Sweden"	                = "SE",
"Switzerland"	            = "CH",
"Syria"	                  = "SY",
"Tunisia"	                = "TN",
"Turkey (in Europe)"	    = "TR",
"Ukraine"	                = "UA",
"United Kingdom"	        = "UK",
"Wales"	                  = "UK",
"Yugoslavia"	            = ""
))
```

## occurrenceStatus

```{r}
distribution %>% 
  group_by(abundance, population_status) %>% 
  summarize(records = n())
```


```{r}
distribution %<>% mutate(dwc_occurrenceStatus = case_when(
  abundance == "Absent or extinct" & population_status !="Extinct"     ~ "absent",
  abundance == "Absent or extinct" & is.na(population_status)          ~ "absent",
  (population_status != "Extinct" | is.na(population_status)) & abundance == "Abundant"       ~ "common",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Common"        ~ "common",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Local"         ~ "present",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Rare"          ~ "rare",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Single record" ~ "present",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Sporadic"      ~ "irregular",
  (population_status != "Extinct" | is.na(population_status))  & abundance == "Unknown"       ~ "doubtful",
  (population_status != "Extinct" | is.na(population_status))  & is.na(abundance)             ~ "",
  population_status == "Extinct"                                    ~ "extinct"))
```

```{r}
distribution %>% 
  group_by(abundance, population_status, dwc_occurrenceStatus) %>% 
  summarize(records = n())
```

## establishmentMeans

```{r}
distribution %>% distinct(species_status)
```

```{r}
distribution %<>% mutate(dwc_establishmentMeans = recode(species_status,
    "Alien" = "introduced",
    "Cryptogenic" = "uncertain",
    "<NA>" = "",
    "Naturalized" = "naturalised",
    "casual" = "naturalised",
    "Alien_invasive" = "invasive")) 
```

## eventDate

Inspect content of `start_year`, which contains the information for `eventDate`:

```{r}
distribution %>% 
  mutate(start_year = as.character(start_year)) %>%
  group_by(start_year) %>% 
  summarize(records = n()) %>%
  arrange(desc(records))
```

Besides a lot of `NA` values, we have many `YYYY` formatted years (good to go) and a smaller group of _others_:

- NA cases:
  * Unknown -> NA
  * unknown -> NA
  * . -> NA
  * ? -> NA
  * since long -> NA
- negative years: also to NA
  * -5300, -2200, -750 -> NA
- before/after cases, question marks,... remove the </>/? signs
  * <1925   -> 1925, i.e. year itself
  * year with question mark, e;g. 1921?, 1930 ? -> year itself is best guess, so extract year
  * 1999\n -> clean to 1999  
- full dates: 10.06.1995., 01/04/1993, 15/10/2005,...  
- multiple years:
  * range of years: 1889-1892  -> take first year
  * options: '2000, 2001'; 1992 or 2010, 2000 OR 2004 -> take first year occurrence
- specials: 20. century, 1957*; 2008**, , 2004, earlier unconformed records, March,1993, 90`s
  * try to extract a 4-digit year (or use Damianos improvd funtionality)

The remaining will probably require some claenup manually. 

Get an overview of the amount of records with just a `YYYY` year format:

```{r}
distribution %>%
  select(start_year) %>%
  filter(str_detect(start_year, "^[0-9]{4}$")) %>% nrow()
```

We also have an amount of negative years to take into account. Let's just consider these with 3 or 4 digits:

```{r}
distribution %>%
  select(start_year) %>%
  filter(str_detect(start_year, "^(-[0-9]{4}|-[0-9]{3})")) %>% nrow()
```

Let's clean the start years information step by step:

1. Everything that is NA or should be NA, make it NA:

```{r}
distribution %<>% 
  mutate(start_year = as.character(start_year)) %>%
  mutate(start_year = replace(start_year, start_year == "Unknown", NA)) %>%
  mutate(start_year = replace(start_year, start_year == "unknown", NA)) %>%
  mutate(start_year = replace(start_year, start_year == ".", NA)) %>%
  mutate(start_year = replace(start_year, start_year == "?", NA)) %>%
  mutate(start_year = replace(start_year, start_year == "since long", NA)) %>%
  mutate(start_year = replace(start_year, start_year == "Since long", NA))

```

2. For all negative values, make it NA:

```{r}
distribution %<>% 
  mutate(start_year = 
           if_else(str_detect(start_year, "^-[0-9]*"),
                   NA_character_, start_year))
```

3. When using a `<` or `>` sign, with a `?` or `\n` added, just take the year:

```{r}
distribution %<>% 
  mutate(start_year = str_replace(start_year, "<|>|\\?", ""))
```

4. When a full date is available, parse it to ISO 8601 date format:

```{r}
full_date_indices <- str_detect(distribution$start_year, 
                                "[0-9]*/[0-9]*/[0-9]*|[0-9]*\\.[0-9]*\\.[0-9]*") & !is.na(distribution$start_year)
parsed_dates <- parse_date_time(distribution$start_year[full_date_indices], orders = "dmy")
parsed_dates_char <- strftime(parsed_dates, "%d-%m-%Y")
distribution$sir_start_year[full_date_indices] <- parsed_dates_char
```

5. When textwise containing a single or multiple years, exrtact the first year in the text:

```{r}
# ignore already parsed dates for this replacement
not_date_indices <- !str_detect(distribution$start_year, 
                               "[0-9]{2}-[0-9]{2}-[0-9]{4}") & !is.na(distribution$start_year)
records_to_parse <- distribution$start_year[not_date_indices]
extracted_years <- if_else(is.na(str_extract(records_to_parse, "[0-9]{4}")),
                           records_to_parse,
                           str_extract(records_to_parse, "[0-9]{4}"))
distribution$start_year[not_date_indices] <- extracted_years
```

5. Replace some specials still present:

First have a look at the specials remaining, not being a integer year (1 or more digits [0-9]) or a formatted date format:

```{r}
distribution  %>%
  select(start_year) %>%
  filter(!str_detect(start_year, "^[0-9]+$|^[0-9]{2}-[0-9]{2}-[0-9]{4}$"))
```

and replace those values:

```{r}
distribution %<>% 
  mutate(start_year = replace(start_year, start_year == "20. century", "1900")) %>%
  mutate(start_year = replace(start_year, start_year == "90`s ", "1990"))
```


recheck cleanup action:

```{r}
distribution  %>%
  select(start_year) %>%
  filter(!str_detect(start_year, "^[0-9]+$|^[0-9]{2}-[0-9]{2}-[0-9]{4}$"))
```

Show content:

```{r}
distribution %>% 
  group_by(start_year) %>% 
  summarize(records = n())
```

Inspect content of `end_year`, which contains the information for `eventDate`:

```{r}
distribution %>% 
  mutate(end_year = as.character(end_year)) %>%
  group_by(end_year) %>% 
  summarize(records = n()) %>%
  arrange(desc(records))
```

Besides a lot of `NA` values, we have many `YYYY` formatted years (good to go) and a smaller group of _others_:

- NA cases:
  * unknown -> NA
  *   -> NA
  * ? -> NA
- negative years: also to NA
  * -2200, -750 -> NA
- before/after cases, question marks,... remove the </>/? signs
  * year with question mark, 2004? -> year itself is best guess, so extract year
- full dates: 15.06.2003.
- specials: 20. century, 1950's*
  try to extract a 4-digit year (or use Damianos improvd funtionality)

The remaining will probably require some claenup manually. 

Get an overview of the amount of records with just a `YYYY` year format:

```{r}
distribution %>%
  select(end_year) %>%
  filter(str_detect(end_year, "^[0-9]{4}$")) %>% nrow()
```

We also have an amount of negative years to take into account. Let's just consider these with 3 or 4 digits:

```{r}
distribution %>%
  select(end_year) %>%
  filter(str_detect(end_year, "^(-[0-9]{4}|-[0-9]{3})")) %>% nrow()
```

Let's clean the start years information step by step:

1. Everything that is NA or should be NA, make it NA:

```{r}
distribution %<>% 
  mutate(end_year = as.character(end_year)) %>%
  mutate(end_year = replace(end_year, end_year == " ", NA)) %>% 
  mutate(end_year = replace(end_year, end_year == "        ", NA)) %>% 
  mutate(end_year = replace(end_year, end_year == "unknown", NA)) %>%
  mutate(end_year = replace(end_year, end_year == "?", NA)) 
```

2. For all negative values, make it NA:

```{r}
distribution %<>% 
  mutate(end_year = 
           if_else(str_detect(end_year, "^-[0-9]*"),
                   NA_character_, end_year))
```

3. When using a `<` or `>` sign, with a `?` or `\n` added, just take the year:

```{r}
distribution %<>% 
  mutate(end_year = str_replace(end_year, "<|>|\\?", ""))
```

4. When a full date is available, parse it to ISO 8601 date format:

```{r}
full_date_indices <- str_detect(distribution$end_year, 
                                "[0-9]*/[0-9]*/[0-9]*|[0-9]*\\.[0-9]*\\.[0-9]*") & !is.na(distribution$end_year)
parsed_dates <- parse_date_time(distribution$end_year[full_date_indices], orders = "dmy")
parsed_dates_char <- strftime(parsed_dates, "%d-%m-%Y")
distribution$end_year[full_date_indices] <- parsed_dates_char
```

5. When textwise containing a single or multiple years, exrtact the first year in the text:

```{r}
# ignore already parsed dates for this replacement
not_date_indices <- !str_detect(distribution$end_year, 
                               "[0-9]{2}-[0-9]{2}-[0-9]{4}") & !is.na(distribution$end_year)
records_to_parse <- distribution$end_year[not_date_indices]
extracted_years <- if_else(is.na(str_extract(records_to_parse, "[0-9]{4}")),
                           records_to_parse,
                           str_extract(records_to_parse, "[0-9]{4}"))
distribution$end_year[not_date_indices] <- extracted_years
```

5. Replace some specials still present:

First have a look at the specials remaining, not being a integer year (1 or more digits [0-9]) or a formatted date format:

```{r}
distribution  %>%
  select(end_year) %>%
  filter(!str_detect(end_year, "^[0-9]+$|^[0-9]{2}-[0-9]{2}-[0-9]{4}$"))
```

and replace those values:

```{r}
distribution %<>% 
  mutate(end_year = replace(end_year, end_year == "19th century", "1800")) %>%
  mutate(end_year = replace(end_year, end_year == "1950's", "1950"))
```


recheck cleanup action:

```{r}
distribution  %>%
  select(end_year) %>%
  filter(!str_detect(end_year, "^[0-9]+$|^[0-9]{2}-[0-9]{2}-[0-9]{4}$"))
```

Show content:

```{r}
distribution %>% 
  group_by(end_year) %>% 
  summarize(records = n())
```

Inspect all combinations for `start_year` and `end_year`:

```{r}
distribution %>% group_by(start_year, end_year) %>% summarize(records = n())
```

Inspect which `end_year` falls before `start_year`:

```{r}
distribution %>% 
  mutate(end_year = as.numeric(end_year)) %>% 
  mutate(start_year = as.numeric(start_year)) %>% 
  filter(end_year < start_year) %>% 
  select(idspecies, end_year, start_year)
```

Create eventDate:

```{r}
distribution %<>% mutate(dwc_eventDate = case_when(
  is.na(start_year) & is.na(end_year) ~ "",
  is.na(start_year) & !is.na(end_year) ~ end_year,
  !is.na(start_year) & is.na(end_year) ~ start_year,
  !is.na(start_year) & !is.na(end_year) ~ paste(start_year, end_year, sep="/")
))
```



Generate occurrenceRemarks:

```{r}
distribution %<>% mutate(dwc_occurrenceRemarks = case_when(
  is.na(region_of_first_record) | region_of_first_record == "" ~ "",
  !is.na(region_of_first_record) ~ paste("region_of_first_record", region_of_first_record, sep = ": ")))
```

## source

Use data in `distribution_references`

Remove all unneccesary fields (preparation for spread):

```{r}
distribution_references %<>% select(sourceid, id_sp_region, field_name, complete_ref) 
```

Remove duplicated records:

```{r}
distribution_references %<>% distinct(id_sp_region, field_name, .keep_all = TRUE)
```

Change from long to wide dataset:

```{r}
distribution_references %<>% spread(field_name, complete_ref)
```

clean column names in `distribution_references`:

```{r}
distribution_references %<>% clean_names() 
```

Use the fields `distribution`, `general_references`,`introduction dates` and `introduction_history` to map under `source`. The other references will be used in the description extension.

Concatenate information in source:

```{r}
distribution_references %<>% mutate(source_distribution = paste(distribution, general_references, introduction_dates, introduction_history, sep = "|")) 
```

Replace `|NA`:

```{r}
distribution_references %<>% mutate(source_distribution = str_replace_all(source_distribution, "([|]NA)|(^NA[|])|(NA)", ""))
```

Add source information to `distribution`:

```{r}
distribution %<>% left_join(
  select(distribution_references, id_sp_region, "source_distribution"),
  by = "id_sp_region")
```

Rename source field:

```{r}
distribution %<>% rename("dwc_source" = "source_distribution")
```


## Post-processing

Keep information on population_status:

```{r}
degree_of_establishment <- distribution %>% 
  select(idspecies, id_sp_region, population_status) %>% 
  distinct(id_sp_region, .keep_all = TRUE)
```

Keep all information on current_distribution:

```{r}
current_distribution <- distribution %>% 
  select(idspecies, id_sp_region, current_distribution) %>% 
  distinct(id_sp_region, .keep_all = TRUE)
```

Keep all information on first_observation:

```{r}
region_first_record <- distribution %>% 
  select(idspecies, id_sp_region, region_of_first_record) %>% 
  distinct(id_sp_region, .keep_all = TRUE)
```

Only keep the Darwin Core columns:

```{r}
distribution %<>% select(starts_with("dwc_"))
```

Drop the `dwc_` prefix:

```{r}
colnames(distribution) <- str_replace(colnames(distribution), "dwc_", "")
```

Preview data:

```{r}
distribution %>% head()
```

Save to CSV:

```{r}
write_csv(distribution, "../data/processed/distribution.csv", na = "")
```

# Description extension

## Pathways

```{r}
pathways %>% 
  group_by(pathway) %>% 
  summarize(records = n())
```

Add regional information:

```{r}
pathways %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Add references:

```{r}
pathways %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid") 
```

Rename to `source`:

```{r}
pathways %<>% rename("source" = "complete_ref") 
```

Map `description`:

```{r}
pathways %<>% mutate(description = paste(locationID, pathway, sep = " - ")) 
```

Map `type`:

```{r}
pathways %<>% mutate(type = "pathway") 
```

Keep only `sourceid`, `description`, `type` and `sourceid`:

```{r}
pathways %<>% select(idspecies, description, type, source)
```

## Vector information

```{r}
vectors %>% 
  group_by(vector2) %>% 
  summarize(records = n())
```

Add regional information:

```{r}
vectors %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Add sources:

```{r}
vectors %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid") 
```

Rename to source:

```{r}
vectors %<>% rename("source" = "complete_ref")
```

Map `description`:

```{r}
vectors %<>% mutate(description = paste(locationID, vector2, sep = " - ")) 
```

Map `type`: 

```{r}
vectors %<>% mutate(type = "vector") 
```

Keep only `sourceid`, `description`, `type` and `source`:

```{r}
vectors %<>% select(idspecies, description, type, source)
```

## Habitat information

Map `description`: 
Unite the information in `ideunis`, `level` and `notes` together to generate one column with habitat information

```{r}
habitat %<>% mutate(description = paste(ideunis, "level", level, "-", habitat))
```

Add sources:

```{r}
habitat %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = c("sourceid")
) 
```

Rename `complete_ref`:

```{r}
habitat %<>% rename("source" = "complete_ref")
```

Map `type`

```{r}
habitat %<>% mutate(type = "eunis_habitat") 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
habitat %<>% select(idspecies, description, type, source)
```

## Native range

filter out information for which `region` is empty:

```{r}
native_range %<>% filter(region != "") 
```

Information for native ranges are duplicated within a certain taxa. This is because for most taxa, we have one record with `notes` populated, and one (or more) records for `last_update`. We only need the taxon x native range information once, so we filter out the duplicates. For this, we make a new column where we combine

```{r}
native_range %<>% distinct(idspecies,region, .keep_all = TRUE)
```

Map `description`:

```{r}
native_range %<>% mutate(description = region) 
```

Map `type`:

```{r}
native_range %<>% mutate(type = "native_range") 
```

Add source:

```{r}
native_range %<>% left_join(
  select(literature_references, sourceid, "complete_ref"),
  by = "sourceid") 
```

Rename `source`:

```{r}
native_range %<>% rename("source" = "complete_ref") 
```

Keep only `idspecies`, `description`, `type` and `sourceid`:

```{r}
native_range %<>% select(idspecies, description, type, source)
```

## Donor area

Remove empty records for `donor_area`:

```{r}
donor_area %<>% filter(region != "") 
```

Add regional information to `donor_area`:

```{r}
donor_area %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Map `description`

```{r}
donor_area %<>% mutate(description = paste(locationID, region, sep = " - ")) 
```

Map `type` 

```{r}
donor_area %<>% mutate(type = "donor_area") 
```

Add source information:

```{r}
donor_area %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid") 
```

Rename `complete_ref`:

```{r}
donor_area %<>% rename("source" = "complete_ref")
```


Keep only `idspecies`, `description`, `type` and `source`:

```{r}
donor_area %<>% select(idspecies, description, type, source)
```

## Ecofunctional group

Inspect ecofunctional group information

```{r}
ecofunctional_group %>% group_by(ecofunct_group) %>% summarize(records = n())
```

Remove rows with no value for `ecofunct_group`

```{r}
ecofunctional_group %<>% filter(ecofunct_group != "")
```

Map `description`

```{r}
ecofunctional_group %<>% mutate(description = ecofunct_group) 
```

Map `type`

```{r}
ecofunctional_group %<>% mutate(type = "ecofunctional_group") 
```

Add source information:

```{r}
ecofunctional_group %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid") 
```

Rename `complete_ref`:

```{r}
ecofunctional_group %<>% rename("source" = "complete_ref")
```


Keep only `idspecies`, `description`, `type` and `source`:

```{r}
ecofunctional_group %<>% select(idspecies, description, type, source)
```

## Taxonomic group

Inspect ecofunctional group information

```{r}
taxon_group %>% group_by(taxon_group) %>% summarize(records = n())
```

Map `description`

```{r}
taxon_group %<>% mutate(description = taxon_group) 
```

Map `type` 

```{r}
taxon_group %<>% mutate(type = "ecofunctional_group") 
```

Add source information:

```{r}
taxon_group %<>% left_join(
  select(literature_references, sourceid, complete_ref),
  by = "sourceid") 
```

Rename `complete_ref`:

```{r}
taxon_group %<>% rename("source" = "complete_ref")
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
taxon_group %<>% select(idspecies, description, type, source)
```

## Impact on ecology

Inspect content:

```{r}
impact %>% group_by(category_ecology) %>% summarize(records = n())
```

Add regional information to `impact`:

```{r}
impact %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Remove empty records:

```{r}
impact_ecology <- impact %<>% filter(category_ecology != "") 
```

Map `description`:

```{r}
impact_ecology %<>% mutate(description = paste(locationID, category_ecology, sep = " - ")) 
```

Map `type`:

```{r}
impact_ecology %<>% mutate(type = "impact_on_ecology")
```

Add source information from distribution_references:

```{r}
impact_ecology %<>% left_join(
  select(filter(
    distribution_references, !is.na(ecoimpact_id)|!is.na(ecological_impact)), 
    id_sp_region, ecoimpact_id, ecological_impact),
  by = "id_sp_region")
```

No duplicates for these references:

```{r}
which(duplicated(impact_ecology$id_sp_region) == TRUE)
```

Map source information:

```{r}
impact_ecology %<>% mutate(source = case_when(
  is.na(ecoimpact_id) & is.na(ecoimpact_id) ~ "",
  !is.na(ecoimpact_id) & is.na(ecological_impact) ~ paste(ecoimpact_id),
  is.na(ecoimpact_id) & !is.na(ecological_impact) ~ paste(ecological_impact),
  !is.na(ecoimpact_id) & !is.na(ecological_impact) ~ paste(ecoimpact_id, ecological_impact, sep ="|")
)) 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
impact_ecology %<>% select(idspecies, description, type, source)
```

## Impact on use

Inspect content:

```{r}
impact %>% group_by(category_uses) %>% summarize(records = n())
```

Remove empty records:

```{r}
impact_use <- impact %<>% filter(category_uses != "") 
```

Map description:

```{r}
impact_use %<>% mutate(description = paste(locationID, category_uses, sep = " - ")) 
```

Map type:

```{r}
impact_use %<>% mutate(type = "impact_on_uses")
```

Add source information from distribution_references:

```{r}
impact_use %<>% left_join(
  select(filter(
    distribution_references, !is.na(useimpact_id)|!is.na(impact_on_uses)), 
    id_sp_region, useimpact_id, impact_on_uses),
  by = "id_sp_region")
```

No duplicates for these references:

```{r}
which(duplicated(impact_use$id_sp_region) == TRUE)
```

Map source information:

```{r}
impact_use %<>% mutate(source = case_when(
  is.na(useimpact_id) & is.na(impact_on_uses) ~ "",
  !is.na(useimpact_id) & is.na(impact_on_uses) ~ paste(useimpact_id),
  is.na(useimpact_id) & !is.na(impact_on_uses) ~ paste(impact_on_uses),
  !is.na(useimpact_id) & !is.na(impact_on_uses) ~ paste(useimpact_id, impact_on_uses, sep ="|")
)) 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
impact_use %<>% select(idspecies, description, type, source)
```

## degree of establishment

```{r}
degree_of_establishment %>% group_by(population_status) %>% summarize(records = n())
```

Remove empty records:

```{r}
degree_of_establishment %<>% filter(population_status != "") 
```

Add regional information to `degree_of_establishment`:

```{r}
degree_of_establishment %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Map `description`:

```{r}
degree_of_establishment %<>% mutate(description = paste(locationID, population_status, sep = " - ")) 
```

Map `type`:

```{r}
degree_of_establishment %<>% mutate(type = "degree_of_establishment")
```

Add source information from distribution_references:

```{r}
degree_of_establishment %<>% left_join(
  select(filter(
    distribution_references, !is.na(status)), 
    id_sp_region, status),
  by = "id_sp_region")
```

No duplicates for these references:

```{r}
which(duplicated(degree_of_establishment$id_sp_region) == TRUE)
```

Map source information:

```{r}
degree_of_establishment %<>% mutate(source = case_when(
  is.na(status) ~ "",
  !is.na(status) ~ paste(status))) 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
degree_of_establishment %<>% select(idspecies, description, type, source)
```

## current distribution

```{r}
current_distribution %>% group_by(current_distribution) %>% summarize(records = n())
```

Remove empty records:

```{r}
current_distribution %<>% filter(current_distribution != "") 
```

Add regional information to `current_distribution`:

```{r}
current_distribution %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Map `description`:

```{r}
current_distribution %<>% mutate(description = paste(locationID, current_distribution, sep = " - ")) 
```

Map `type`:

```{r}
current_distribution %<>% mutate(type = "current_distribution")
```

Add source information from distribution_references:

```{r}
current_distribution %<>% left_join(
  select(filter(
    distribution_references, !is.na(current_distrib) | !is.na(current_distribution)), 
    id_sp_region, current_distrib, current_distribution),
  by = "id_sp_region")
```

No duplicates for these references:

```{r}
which(duplicated(current_distribution$id_sp_region) == TRUE)
```

Map source information:

```{r}
current_distribution %<>% mutate(source = case_when(
  is.na(current_distrib) & is.na(current_distribution.y) ~ "",
  !is.na(current_distrib) & is.na(current_distribution.y) ~ paste(current_distrib),
  is.na(current_distrib) & !is.na(current_distribution.y) ~ paste(current_distribution.y),
  !is.na(current_distrib) & !is.na(current_distribution.y) ~ paste(current_distrib, current_distribution.y, sep = "|"))) 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
current_distribution %<>% select(idspecies, description, type, source)
```

## Region of first observation

```{r}
region_first_record %>% group_by(region_of_first_record) %>% summarize(records = n())
```

Remove empty records:

```{r}
region_first_record %<>% filter(region_of_first_record != "") 
```

Add regional information to `region_first_record`:

```{r}
region_first_record %<>% left_join(
  select(species_localities, id_sp_region, locationID),
  by = "id_sp_region") 
```

Map `description`:

```{r}
region_first_record %<>% mutate(description = paste(locationID, region_of_first_record, sep = " - ")) 
```

Map `type`:

```{r}
region_first_record %<>% mutate(type = "region_of_first_record")
```

Add source information from distribution_references:

```{r}
region_first_record %<>% left_join(
  select(filter(
    distribution_references, !is.na(first_observation)), 
    id_sp_region, first_observation),
  by = "id_sp_region")
```

No duplicates for these references:

```{r}
which(duplicated(region_first_record$id_sp_region) == TRUE)
```

Map source information:

```{r}
region_first_record %<>% mutate(source = case_when(
  is.na(first_observation) ~ "",
  !is.na(first_observation) ~ paste(first_observation))) 
```

Keep only `idspecies`, `description`, `type` and `source`:

```{r}
region_first_record %<>% select(idspecies, description, type, source)
```

## Union information:

```{r start_description_ext}
description <- bind_rows(
  pathways, 
  vectors, 
  habitat, 
  native_range, 
  donor_area, 
  ecofunctional_group, 
  taxon_group, 
  impact_ecology, 
  impact_use, 
  degree_of_establishment,
  current_distribution,
  region_first_record)
```

Map to DwC terms:

### taxonID

```{r}
description %<>% mutate(dwc_taxonID = idspecies)
```

### description

```{r}
description %<>% mutate(dwc_description = description)
```

### type

```{r}
description %<>% mutate(dwc_type = type) 
```

### source

```{r}
description %<>% mutate(dwc_source = source) 
```

## Post-processing

1. Only keep the Darwin Core columns.
  
```{r}
description %<>% select(starts_with("dwc_"))
```
  
2. Drop the `dwc_` prefix.
  
```{r}
colnames(description) <- str_replace(colnames(description), "dwc_", "")
```

3. Sort on `taxonID`.

```{r}
description %<>% arrange(taxonID)
```

4. Preview data:

```{r}
description %>% head()
```

5. Save to [CSV]().

```{r}
write_csv(description, "../data/processed/description.csv", na = "")
```



